---
description: 规范化单元测试编写，确保测试覆盖率和质量
globs: test_*.py
alwaysApply: false
---

# 单元测试规范

## 核心原则宣言

⚡️ 核心问题：如何使用pytest框架编写高质量的单元测试，确保代码功能的正确性和可维护性。

💥 不遵循的后果：
- 测试可能遗漏关键场景，导致潜在bug未被发现
- 测试代码难以维护，成为开发负担
- 测试结果不可靠，无法提供质量保证
- 测试执行效率低，降低开发速度

💎 遵循的收益：
- 及早发现代码问题，降低修复成本
- 提高代码质量，减少生产环境问题
- 代码更易于重构，支持持续优化
- 测试作为活文档，帮助理解代码行为

⚖️ 需要权衡：
- 权衡点1：测试覆盖率 VS 开发效率
- 权衡点2：测试隔离性 VS 测试真实性
- 权衡点3：测试简洁性 VS 测试完备性

## 关键实践

### 实践一：Pytest测试结构与组织

为什么需要这样做：
良好的测试结构使测试更易于编写、理解和维护，同时利用pytest的强大功能。

❌ 常见错误：
```python
# 混乱的测试结构
def test_something():
    # 准备数据
    user = create_user()
    # 执行操作
    result = user.activate()
    # 断言结果
    assert result == True
    # 再执行一个操作 - 违反单一职责
    user.update_profile(name="New Name")
    # 断言更多结果
    assert user.name == "New Name"
```

✅ 正确做法：
```python
import pytest

# 使用fixtures准备测试数据
@pytest.fixture
def active_user():
    user = create_user()
    return user

# 清晰的测试函数，单一职责
def test_user_activation(active_user):
    # 执行操作
    result = active_user.activate()
    # 断言结果，包含失败消息
    assert result is True, "User activation should return True"

# 分离的测试函数
def test_user_profile_update(active_user):
    # 执行操作
    active_user.update_profile(name="New Name")
    # 断言结果
    assert active_user.name == "New Name"
```

🔄 重构路径：
1. 将测试数据准备移至fixtures
2. 拆分多个断言为独立的测试函数
3. 添加有意义的失败消息
4. 确保测试函数名称能描述被测行为

### 实践二：使用Pytest的高级功能

为什么需要这样做：
Pytest提供了丰富的功能来简化测试、增强可读性和提高测试效率。

❌ 常见错误：
```python
# 未充分利用pytest功能
def test_division():
    assert divide(10, 2) == 5
    assert divide(8, 4) == 2
    assert divide(9, 3) == 3
    # 无法处理预期异常
    try:
        divide(5, 0)
        assert False  # 不应该到达这里
    except ZeroDivisionError:
        assert True  # 糟糕的异常测试
```

✅ 正确做法：
```python
import pytest

# 使用参数化测试简化多个类似用例
@pytest.mark.parametrize("a,b,expected", [
    (10, 2, 5),
    (8, 4, 2),
    (9, 3, 3),
])
def test_division(a, b, expected):
    assert divide(a, b) == expected

# 清晰地测试异常
def test_division_by_zero():
    with pytest.raises(ZeroDivisionError):
        divide(5, 0)
```

🔄 重构路径：
1. 识别可以参数化的测试用例
2. 使用pytest.mark.parametrize简化重复测试
3. 用pytest.raises替代try/except测试异常
4. 利用pytest.mark标记分类测试用例

### 实践三：恰当的测试隔离和Mocking

为什么需要这样做：
良好的测试隔离确保测试结果可靠，不受外部因素影响，同时关注真正需要测试的逻辑。

❌ 常见错误：
```python
# 直接访问数据库的测试
def test_user_repository():
    # 直接依赖真实数据库
    repo = UserRepository()
    user = repo.get_by_id(1)  # 可能不稳定
    assert user.name == "Admin"  # 依赖数据库内容
```

✅ 正确做法：
```python
# 使用pytest-mock提供的mocker夹具
def test_user_repository(mocker):
    # 模拟数据库连接
    mock_db = mocker.patch('app.database.get_connection')
    mock_db.return_value.execute.return_value = [
        {"id": 1, "name": "Admin"}
    ]
    
    repo = UserRepository()
    user = repo.get_by_id(1)
    
    # 验证结果
    assert user.name == "Admin"
    # 验证交互
    mock_db.return_value.execute.assert_called_once()

# 使用monkeypatch测试夹具
def test_config_loading(monkeypatch):
    # 临时修改环境变量
    monkeypatch.setenv("API_KEY", "test-key")
    
    config = load_config()
    assert config.api_key == "test-key"
```

🔄 重构路径：
1. 识别需要隔离的外部依赖
2. 选择合适的mock策略（mocker, monkeypatch等）
3. 验证结果和交互
4. 确保测试只关注相关行为

## 决策指导

🌲 决策树：
1. 测试方法选择
   - 测试多个输入输出组合 -> 使用参数化测试
   - 测试异常情况 -> 使用pytest.raises
   - 测试需要共享设置 -> 使用fixtures

2. Mock策略选择
   - 替换外部服务调用 -> 使用mocker.patch
   - 修改环境/配置 -> 使用monkeypatch
   - 需完全控制对象行为 -> 使用MagicMock
   - 需部分真实行为 -> 使用spy

3. 测试组织策略
   - 按功能模块组织测试 -> 使用测试类或目录结构
   - 区分测试类型 -> 使用自定义标记(pytest.mark)
   - 需要共享fixtures -> 使用conftest.py

📊 方案对比：
| 测试方法 | 优势 | 劣势 | 适用场景 |
|---------|-----|-----|---------|
| 参数化测试 | 简洁，覆盖多个用例 | 用例间相似，灵活性低 | 相同逻辑，不同输入输出 |
| 标准单元测试 | 灵活，可定制性高 | 可能有重复代码 | 复杂逻辑，多步骤流程 |
| Fixture驱动 | 可重用，专注测试逻辑 | 增加间接性 | 需要复杂设置的测试 |

## Checklist

#### 测试设计阶段
- [ ] 测试命名是否符合惯例
      判断标准：使用test_开头，名称描述被测行为
      快速修复：重命名为"test_should_when"模式

- [ ] 是否充分利用pytest fixtures
      判断标准：重复的测试设置移至fixtures
      快速修复：提取共享设置到fixtures或conftest.py

- [ ] 测试是否涵盖正常、异常和边界情况
      判断标准：包含成功路径、失败路径和边界值测试
      快速修复：添加缺失的测试场景

#### 测试实现阶段
- [ ] 是否使用了适当的pytest断言
      判断标准：使用清晰的断言，包含失败消息
      快速修复：替换为更精确的断言表达式

- [ ] 是否合理使用参数化测试
      判断标准：类似测试用例使用参数化
      快速修复：将重复测试转为参数化测试

- [ ] 是否正确处理了异常测试
      判断标准：使用pytest.raises而非try/except
      快速修复：重构为pytest.raises模式

#### 测试维护阶段
- [ ] 测试是否易于理解
      判断标准：简洁清晰，注释合理
      快速修复：添加文档注释，简化复杂逻辑

- [ ] 测试是否可靠且快速
      判断标准：不包含不确定因素，执行迅速
      快速修复：增强隔离性，减少不必要操作

- [ ] 测试依赖是否最小化
      判断标准：只mock必要组件，减少测试间依赖
      快速修复：检查并隔离不必要的依赖 