---
description: 规范化模块导入顺序和依赖管理，避免循环依赖，提高代码可维护性
globs: *.py
alwaysApply: false
---

# 模块导入规范

## 核心原则宣言

⚡️ 核心问题：不规范的模块导入会导致代码难以维护、依赖混乱和潜在的循环引用问题。

💥 不遵循的后果：
- 循环依赖导致运行时错误
- 导入路径问题使模块无法独立运行
- 模块间耦合度高，难以重构
- 位置依赖导致代码可移植性差

💎 遵循的收益：
- 清晰的依赖关系，便于理解和维护
- 模块可以从任何位置正确导入和运行
- 支持独立测试和模块化开发
- 减少"它在我机器上能运行"的问题

⚖️ 需要权衡：
- 权衡点1：环境初始化的开销 VS 代码可靠性
- 权衡点2：统一导入风格 VS 特殊场景需求
- 权衡点3：显式导入路径 VS 代码简洁性

## 关键实践

### 实践一：环境初始化与项目根目录

为什么需要这样做：
正确设置项目环境确保代码可以从任何位置运行，并使绝对导入路径可靠地工作。

❌ 常见错误：
```python
# 直接使用相对导入，导致模块无法独立运行
from ..utils import helper

# 或者使用硬编码的路径
import sys
sys.path.append('/absolute/path/to/project')
```

✅ 正确做法：
```python
# 在文件顶部加载环境变量
import logging
import re
from dotenv import load_dotenv
load_dotenv()  # 加载项目根目录的.env文件，其中应包含PYTHONPATH=.

# 此后使用绝对导入路径（从项目根目录开始）
from my_project.utils import helper
from my_project.core import models
```

🔄 重构路径：
1. 在项目根目录创建`.env`文件，设置`PYTHONPATH=.`
2. 在模块顶部添加环境初始化代码
3. 将相对导入改为绝对导入
4. 测试模块的独立运行能力

### 实践二：导入分组与顺序

为什么需要这样做：
统一的导入顺序使代码更易读，也便于识别各种依赖的来源和重要性。

❌ 常见错误：
```python
# 混乱的导入顺序
import random
from my_project.utils import helper
from django.http import HttpResponse
import os
from . import local_module
import sys
```

✅ 正确做法：
```python
# 标准库导入
import os
import sys
import random

# 第三方库导入
from django.http import HttpResponse

# 环境初始化（应放在所有导入之前或紧跟标准库, 第三方库导入）
from dotenv import load_dotenv
load_dotenv()

# 本地模块导入（使用绝对路径）
from my_project.utils import helper
from my_project.current_package import local_module
```

🔄 重构路径：
1. 按照推荐顺序整理导入语句
2. 确保环境初始化在合适位置
3. 使用绝对路径替换相对导入
4. 验证导入的正确性

### 实践三：模块独立可运行

为什么需要这样做：
使模块能够独立运行可以方便测试和开发，提高代码的可维护性。

❌ 常见错误：
```python
# 没有__main__部分，无法直接运行
def process_data(data):
    return [item.upper() for item in data]

# 或依赖特定的运行路径
if __name__ == "__main__":
    import sys
    sys.path.append("../..")  # 脆弱的路径处理
    from my_project.data import test_data
    results = process_data(test_data)
    print(results)
```

✅ 正确做法：
```python
# 开头进行环境初始化
from dotenv import load_dotenv
load_dotenv()

def process_data(data):
    return [item.upper() for item in data]

if __name__ == "__main__":
    # 得益于环境初始化，可以使用绝对导入
    from my_project.data import test_data
    # 或者使用内联测试数据
    # test_data = ["test1", "test2"]
    results = process_data(test_data)
    print(results)
```

🔄 重构路径：
1. 添加环境初始化代码
2. 实现__main__部分进行简单测试
3. 使用绝对导入替换相对路径或硬编码路径
4. 验证模块可以独立运行

## 决策指导

🌲 决策树：
1. 环境初始化
   - 是复杂项目 -> 在项目根添加.env文件，设置PYTHONPATH=.
   - 是简单脚本 -> 考虑内联路径处理
   
2. 导入路径选择
   - 有环境初始化 -> 使用绝对导入（从项目根开始）
   - 无环境初始化 -> 仅在包内使用相对导入
   
3. 模块测试策略
   - 是核心功能模块 -> 添加__main__测试段
   - 是辅助工具/类 -> 可选添加简单的使用示例

📊 方案对比：
| 方案 | 优势 | 劣势 | 适用场景 |
|-----|-----|-----|---------|
| 环境初始化+绝对导入 | 可靠，位置无关，支持独立运行 | 需要初始化步骤 | 中大型项目，多人协作 |
| 相对导入 | 代码简洁 | 依赖包结构，不支持独立运行 | 包内模块互相引用 |
| 系统路径修改 | 简单直接 | 脆弱，依赖运行环境 | 简单脚本，临时解决方案 |

## Checklist

#### 环境设置阶段
- [ ] 项目根目录是否有正确配置的.env文件
      判断标准：包含PYTHONPATH=.设置
      快速修复：创建或更新.env文件

- [ ] 模块顶部是否有环境初始化代码
      判断标准：import后跟load_dotenv()调用
      快速修复：添加适当的环境初始化代码

#### 编写代码阶段
- [ ] 导入是否按类型分组并正确排序
      判断标准：标准库→环境初始化→第三方库→本地模块
      快速修复：重排导入语句

- [ ] 是否使用绝对导入路径
      判断标准：导入路径从项目根目录开始
      快速修复：将相对路径转换为绝对路径

- [ ] 模块是否可以独立运行
      判断标准：包含__main__测试段且不依赖特定运行路径
      快速修复：添加环境初始化和简单测试代码

#### 重构与验证阶段
- [ ] 是否消除了循环依赖
      判断标准：没有模块间的相互导入
      快速修复：重构代码，使用延迟导入或依赖注入

- [ ] 模块是否能从任意位置导入和运行
      判断标准：在不同目录下运行测试
      快速修复：检查和修复环境初始化和导入路径 