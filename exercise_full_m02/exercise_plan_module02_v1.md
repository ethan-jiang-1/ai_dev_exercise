# NovaBrain 3.0 模拟练习计划 编码与开发阶段

> **根目录说明**: 本练习计划中所有相对路径均以本文件所在目录 `exercise_full_m02/` 为根目录。例如，当看到 `./setting/` 时，实际指向的是 `exercise_full_m02/setting/` 目录。

**模块目标**: 评估和体验 AI 助手 (如 Cursor) 如何在**编码与开发阶段**辅助进行代码生成与优化、设计模式应用、技术选型评审、代码质量保障和开发效率提升等活动，使用 TechNova AI 案例（**包含核心案例与外部设定**）作为模拟环境。

## 模块目标与背景

**模块目标**：评估和体验 AI 助手（如 Cursor）在以下关键活动中的辅助能力：
- 代码生成与优化
- 设计模式应用
- 技术选型评审
- 代码质量保障
- 开发效率提升等活动

本模块使用 TechNova AI 案例作为模拟环境（已包含更新的外部设定）。

**与 LLM 的交互方式**：
- 所有输出应以中文为主；
- 推理过程可使用模型习惯语言（如英文）；
- 鼓励中文注释与中文命名。

**练习输出说明**：
- 所有练习产生的分析、草稿、日志、代码等，默认使用中文或包含中文注释，除非另有说明。
---

## 熟悉目标所需阅读材料

**案例背景**：
- `case_study_NovaBrain.md`：核心背景、项目挑战、技术栈等。

**角色与团队**：
- `case_study_people_and_teams.md`：角色画像、团队动态与决策风格。

**外部环境设定**：
- `setting_competitive_landscape.md`
- `setting_industry_adoption.md`
- `setting_technology_trends.md`

---

## 输入与输出目录说明

**输入目录**：
- `./setting/`
- `./module02/`

**输出目录**：
- 请依据每项练习中的指示进行输出，默认不在此处统一指定。

---

## 模块 02  练习: 编码与开发

### Ex2_0_SimpleCodeExplain: 理解并解释代码片段 (入门)

*   **目标**: 练习使用 AI 阅读并解释一段给定的、相对独立的 Python 代码片段的功能、输入、输出和基本逻辑。这是理解现有代码的基础。
*   **理论/结构**: 代码阅读与理解。步骤：提供代码 -> AI 读取 -> AI 解释。
*   **输入**:
    *   `./module02/code_for_refactoring_example.py`
*   **AI 助手角色**:
    *   读取指定的 Python 代码文件。
    *   用自然语言（中文）解释代码的主要功能或目的。
    *   识别关键函数/方法的输入参数和返回值。
    *   (可选) 简要说明其核心逻辑步骤。
*   **复杂度分析**: 低。处理单一代码文件，任务是理解和解释，而非修改或复杂分析。直接对应 M02 的代码理解需求。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_0_SimpleCodeExplain/`
    *   **最终产物**: 一个 Markdown 文件，包含对代码的解释，例如 `ex2_0_code_explanation_v1.md`。

### Ex2_0_SimpleStandardCheck: 对照标准检查代码风格 (入门)

*   **目标**: 练习使用 AI 对照一个简单的开发规范片段，检查代码中是否存在明显违反规范的地方（例如命名约定、注释要求）。
*   **理论/结构**: 规范遵循性检查。步骤：提供代码和规范 -> AI 读取两者 -> AI 对比 -> AI 报告违规点。
*   **输入**:
    *   `./module02/code_for_refactoring_example.py`
    *   `./module02/simple_dev_standard_snippet.md`
*   **AI 助手角色**:
    *   读取代码文件和简化的规范片段。
    *   识别代码中明确违反规范片段中定义规则的地方。
    *   列出具体的违规行号和违反的规范。
*   **复杂度分析**: 低-中。需要处理两个文件（代码、规范），进行简单的模式匹配和规则应用。为后续 Ex2_5, Ex2_6, Ex2_8 等涉及开发规范的练习打基础。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_0_SimpleStandardCheck/`
    *   **最终产物**: 一个 Markdown 文件，列出代码中违反简单规范的地方，例如 `ex2_0_standard_violations_v1.md`。

### Ex2_0_SimpleFuncGen: 根据简单规约生成函数 (入门)

*   **目标**: 练习使用 AI 基于一段清晰、简单的功能描述（规约），生成符合要求的函数代码，并可能需要遵循最基本的编码标准（如添加注释）。
*   **理论/结构**: 基于规约的代码生成（极简版）。步骤：提供规约 -> AI 理解 -> AI 生成代码。
*   **输入**:
    *   `./module02/feature_spec_simple_math_func.md`
    *   (可选) `./module02/simple_dev_standard_snippet.md` (如果规范里有关于 Docstring 或错误处理的基本要求)
*   **AI 助手角色**:
    *   读取功能规约（和可选的规范片段）。
    *   生成符合规约描述的 Python 函数代码，包括逻辑、输入检查和 Docstring。
*   **复杂度分析**: 中。涉及代码生成，但规约非常简单明确，限制了复杂度。这是 Ex2_7, Ex2_10, Ex2_11 等更复杂代码生成任务的入门版。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_0_SimpleFuncGen/`
    *   **最终产物**: 一个 Python 代码文件，包含生成的函数，例如 `ex2_0_generated_math_func.py`。

### Ex2_1_TechDesignReview : 技术选型/设计评审模拟

*   **目标**: 模拟模型注册表 (或 Low-Code API `PATCH` 实现) 的技术设计评审会议，聚焦于不同角色关注点的碰撞，**并考虑相关技术趋势与竞争格局**。
*   **输入**: 
    *   `./setting/case_study_people_and_teams.md` (人物画像: CTO 张弓, 工程负责人王强, 相关技术负责人如李工/孙工)
    *   `./setting/setting_technology_trends.md`
    *   `./setting/setting_competitive_landscape.md`
    *   `./module02/tech_design_model_registry_v1.md` (技术设计: 模型注册表)
    *   `./module02/api_design_review_lowcode_engine_v0.1.md` / `./module02/api_changelog_lowcode_v0.1_to_v0.2.md` (API 设计/变更)
    *   `./module02/architecture_decision_record_003_model_serving_grpc_vs_rest.md` (ADR)
    *   `./module02/sprint_retrospective_notes_2023_11_15.md` (Sprint 回顾)
    *   `./module02/tech_design_review_external_v1.md` (技术设计评审外部原始素材)
*   **AI 助手 (Cursor) 的角色**:
    *   **文档理解与总结**: 快速理解设计文档的核心内容和关键决策点。
    *   **模拟评审意见**: 基于人物画像，模拟 CTO 对架构长远性的考量、工程负责人对稳定性和可运维性的关注、技术负责人对实现复杂度的反馈。**需引入外部技术和竞争视角**（如"竞争对手 X 如何做？""是否符合 Y 技术趋势？"）。
    *   **风险识别**: 基于设计文档和讨论，识别潜在的技术风险、集成问题或**技术竞争力风险**。
    *   **行动项提取**: 总结评审会议的关键决定和后续行动项。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_1_TechDesignReview/`
    *   **主要输出**: 练习中的文档总结、模拟评审意见、风险识别结果主要体现在**交互对话**记录中。
    *   **最终产物**: 提取的行动项和关键讨论点（文件内容应为中文），可以整理后保存为日志文件 `exercise_2_1_design_review_log.md`。

### Ex2_2_SprintAnalysis : Sprint 问题分析与改进建议

*   **目标**: 基于 Sprint 回顾笔记中反映的问题（如 `PATCH` API 延期、Staging 环境不稳），深入分析根本原因并提出改进措施。
*   **输入**: 
    *   `./setting/case_study_people_and_teams.md` (人物画像: 王强, 孙工, 赵工, 周工; 团队动态: 协作挑战, 近期冲突示例)
    *   `./module02/sprint_retrospective_notes_2023_11_15.md` (Sprint 回顾: 23.11a)
*   **AI 助手 (Cursor) 的角色**:
    *   **问题关联分析**: 尝试将回顾中提到的问题与团队动态、人员特点或之前的决策联系起来。**(可引导思考外部压力等间接因素)**。
    *   **根本原因假设**: 提出可能的根本原因（RCA）供团队讨论。
    *   **改进措施建议**: 基于分析，提出具体的、可操作的改进建议（例如，改进 Sprint Planning 估算方法、加强环境监控、优化跨团队沟通机制）。
    *   **会议纪要补充**: 协助王强（角色扮演）丰富回顾会议的分析和改进计划部分。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_2_SprintAnalysis/`
    *   **主要输出**: 练习中的问题关联分析、根本原因假设、改进建议主要体现在**交互对话**记录中。
    *   **最终产物**: 补充后的会议纪要分析（或相关分析片段，文件内容应为中文），建议保存为文件 `exercise_2_2_sprint_retro_analysis_draft_v1.md`。

### Ex2_3_UiUxReview : UI/UX 设计评审与优化

*   **目标**: 评审 Low-Code 引擎的 UI 原型设计，确保满足直觉性操作和专业用户需求，**并借鉴相关行业最佳实践和技术趋势**。
*   **输入**: 
    *   `./setting/case_study_NovaBrain.md` (客户案例：MediScan, FinSecure 的用户特征)
    *   `./setting/case_study_people_and_teams.md` (人物画像: 产品负责人钱静, 前端负责人刘芳或产品负责人钱静)
    *   `./setting/setting_industry_adoption.md`
    *   `./setting/setting_competitive_landscape.md`
    *   `./setting/setting_technology_trends.md`
    *   `./module01/prd_snippet_multimodal_fusion_v0.1.md` (PRD 片段: 多模态融合, 注意来自 Module01)
    *   `./module02/ui_prototype_lowcode_dashboard_v1.md` (UI 原型设计: Low-Code 仪表盘)
    *   `./module02/uiux_review_external_v1.md` (UI/UX 设计评审外部原始素材)
*   **AI 助手 (Cursor) 的角色**:
    *   **用户流程分析**: 评估用户完成核心任务的流程是否直观、步骤是否合理。
    *   **交互模式评估**: 分析界面交互模式是否符合目标用户（**特别是医疗场景下的研究人员等**）的使用习惯。**引入跨行业比较**（如电商/金融简洁性）。
    *   **可用性问题识别**: 识别原型中可能的可用性问题。
    *   **UI 优化建议**: 提供具体的界面元素、布局、信息架构优化建议，**需结合竞品、行业趋势和医疗用户特点**，并模拟不同角色对设计的反馈。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_3_UiUxReview/`
    *   **主要输出**: 练习中的用户流程分析、交互模式评估、可用性问题识别和优化建议主要体现在**交互对话**记录中。
    *   **最终产物**: UI/UX 评审总结和优化建议（文件内容应为中文），建议保存为文件 `exercise_2_3_ui_review_suggestions_v1.md`。

### Ex2_4_FrontBackendIntegration : 前后端协作与集成点设计

*   **目标**: 模拟前后端团队讨论 API 集成、状态管理和数据流设计，确保无缝协作。
*   **输入**: 
    *   `./setting/case_study_people_and_teams.md` (人物画像: 前端负责人刘芳, 后端负责人孙工)
    *   `./module02/frontend_tech_stack_novabrain_v3.md` (前端技术栈文档)
    *   `./module02/api_design_review_lowcode_engine_v0.1.md` (API 设计)
    *   `./module02/api_changelog_lowcode_v0.1_to_v0.2.md` (API 变更日志)
*   **AI 助手 (Cursor) 的角色**:
    *   **接口契约分析**: 审核 API 设计是否满足前端需求，识别潜在的接口问题或缺失。
    *   **数据流程图生成**: 为特定功能（如模型部署流程）绘制前后端数据流程图，明确数据传递路径和状态变化。
    *   **集成风险预测**: 预测可能的集成问题，如数据格式不一致、状态同步失败等。
    *   **协作指南建议**: 提出提升前后端团队协作效率的具体建议，如接口变更通知机制、Mock 数据规范等。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_4_FrontBackendIntegration/`
    *   **主要输出**: 练习中的接口契约分析、数据流程图、集成风险预测和协作指南建议主要体现在**交互对话**记录中。
    *   **最终产物**: 前后端协作方案和集成点设计（文件内容应为中文），建议保存为文件 `exercise_2_4_frontend_backend_integration_plan_v1.md`。

### Ex2_5_CodeImplementation : 代码实现与优化挑战

*   **目标**: 模拟实现特定功能模块（如模型参数管理或**多模态处理管道**）的代码设计和优化，**必要时考虑最新的技术趋势和医疗行业要求**。
*   **输入**: 
    *   `./setting/case_study_NovaBrain.md` (技术栈和性能要求)
    *   `./setting/case_study_people_and_teams.md` (人物画像: 技术负责人)
    *   `./setting/setting_technology_trends.md` (特别是针对前沿功能)
    *   `./setting/setting_industry_adoption.md` (特别是针对医疗要求)
    *   `./module02/feature_spec_model_params_management.md` (功能规格: 模型参数管理) 或其他模块规格
    *   `./module02/code_structure_backend_services.md` (现有代码结构)
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范)
*   **AI 助手 (Cursor) 的角色**:
    *   **代码结构建议**: 提出符合现有架构风格和最佳实践的代码结构设计。 **(若提供了开发规范) 确保建议符合规范文档中的约定**。
    *   **设计模式应用**: 推荐适用于特定功能实现的设计模式。
    *   **性能与可靠性优化**: 识别潜在瓶颈，提出优化策略，**需特别关注医疗场景下的可靠性、安全性和合规性要求**。
    *   **实现方案比较**: 提出不同实现方案，并从可扩展性、性能、可维护性、**技术前瞻性（结合趋势）**、**行业适用性**等维度进行比较分析。 **(若提供了开发规范) 评估方案是否符合规范**。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_5_CodeImplementation/`
    *   **主要输出**: 练习中的代码结构建议、设计模式应用、优化策略和实现方案比较主要体现在**交互对话**记录中。
    *   **最终产物**: 代码实现方案设计（文件内容应为中文），建议保存为文件 `exercise_2_5_code_implementation_design_v1.md`。

### Ex2_6_DevStandards : 开发规范与文档化策略

*   **目标**: 为 NovaBrain 3.0 项目制定团队开发规范和文档化策略，提高代码质量和团队协作效率，**特别关注医疗等受监管行业的需求，并使其能够被 AI 理解和应用以指导后续开发活动**。
*   **输入**: 
    *   `./setting/case_study_NovaBrain.md` (技术栈复杂度)
    *   `./setting/case_study_people_and_teams.md` (团队组成特点)
    *   `./setting/setting_industry_adoption.md` (医疗行业合规要求)
    *   `./module02/current_dev_processes_202311.md` (现有开发流程)
    *   `./module02/sprint_retrospective_notes_2023_11_15.md` (Sprint 回顾中的痛点)
*   **AI 助手 (Cursor) 的角色**:
    *   **规范模板生成**: 基于项目和团队特点，生成规范模板（代码风格、命名约定、测试要求、提交规范等），**需融入医疗行业的合规考量**（如代码审查标准、可追溯性要求）。
    *   **文档结构推荐**: 推荐适合项目的文档结构，**需考虑满足审计和合规需求的文档类型和深度**。
    *   **自动化文档工具建议**: 结合技术栈，推荐工具。
    *   **采纳激励机制设计**: 设计机制。
    *   **规范可应用性**: **生成的规范文档应结构清晰 (例如使用 Markdown 标题和列表)，便于 AI 在后续练习中（当被要求时）读取并遵循其中的约定**。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_6_DevStandards/`
    *   **主要输出**: 练习中的规范模板、文档结构推荐、工具建议和激励机制设计主要体现在**交互对话**记录中。
    *   **最终产物**: 团队开发规范和文档化策略草案 (**强调其 AI 可读性**，文件内容应为中文或包含充分中文注释)，建议保存为文件 `exercise_2_6_dev_standards_documentation_strategy_v1.md`。

### Ex2_7_TDD : 测试驱动开发 (TDD) 与 AI 协同

*   **目标**: 实践 TDD 流程，重点在于**先编写测试用例 (或清晰的测试意图描述)**，然后利用 AI (Cursor) 生成满足测试的代码，体验 AI 如何辅助实现"测试先行"的开发模式，培养将重心放在思考约束与预期而非直接编码的习惯。
*   **核心理念**: 将工作重点从直接编写实现代码，转移到**思考和描述代码行为的约束与预期 (即测试)**，利用 AI 加速"红-绿-重构"循环中的"绿"和"重构"环节。
*   **输入**: 
    *   `./setting/setting_technology_trends.md` (参考测试框架趋势)。
    *   `./setting/setting_industry_adoption.md` (行业特定的测试覆盖要求)。
    *   `./module02/feature_spec_tdd_example.md` (某个具体的功能需求或用户故事)
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范中的测试部分)
    *   相关的代码上下文或接口定义。
*   **AI 助手 (Cursor) 的角色**:
    *   **测试用例生成辅助**: 根据需求描述或关键点，**协助生成单元测试框架或关键断言**。 **(若提供了开发规范) 测试用例需符合规范要求**。
    *   **基于测试生成代码**: **根据用户提供的测试用例 (或测试意图)，生成能够通过这些测试的实现代码**。
    *   **测试失败分析**: 当生成的代码未通过测试时，**分析失败原因，并提出修改代码或测试用例的建议**。
    *   **重构建议 (TDD循环)**: 在测试通过后，**对生成的代码提出重构建议**，以提升代码质量。 **(若提供了开发规范) 重构建议需符合规范**。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_7_TDD/`
    *   **主要输出**: 练习中的测试用例、AI 生成的代码、测试失败分析、重构建议主要体现在**交互对话**记录中。
    *   **最终产物**: 完整的测试用例集、通过测试并经过初步重构的实现代码（代码需包含中文注释）、TDD 过程日志（文件内容应为中文），建议保存为 `exercise_2_7_feature_with_tests.[py|java|...]` 和 `exercise_2_7_tdd_ai_collaboration_log.md`。

### Ex2_8_CodeRefactoring : AI 辅助代码重构

*   **目标**: 练习使用 AI (Cursor) 对一段现有代码（可能是之前练习中 AI 生成的，或是一段模拟的遗留代码）进行重构，提升其可读性、可维护性和结构，实践"人指导、AI执行"的重构模式。
*   **核心理念**: 探索 AI 在理解代码、识别代码坏味道、应用重构模式方面的能力，以及如何**精确指导 AI** 进行符合团队规范和设计原则的、安全的重构。
*   **输入**: 
    *   `./setting/setting_technology_trends.md` (参考现代重构模式和原则)。
    *   `./module02/code_for_refactoring_example.[py|java|...]` (一段需要重构的代码)
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范文档)。
    *   (可选) 相关的单元测试，用于验证重构安全性。
*   **AI 助手 (Cursor) 的角色**:
    *   **代码分析与坏味道识别**: **分析给定代码，识别潜在的可重构点** (如过长函数、重复代码、复杂条件等)，并向用户报告。
    *   **重构建议与模式应用**: **根据识别的坏味道或用户的明确指令 (例如"请将这段代码提取为方法 X")，提出具体的重构建议或直接执行重构操作**。 **(若提供了开发规范) 确保重构建议和操作符合规范文档中的约定**。
    *   **解释重构影响**: (可选) 解释某项重构可能带来的好处和潜在风险。
    *   **逐步重构支持**: 支持用户进行一系列小的、安全的重构步骤，而不是一次性进行大的改动。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_8_CodeRefactoring/`
    *   **主要输出**: 练习中的代码分析结果、重构建议、执行的重构步骤主要体现在**交互对话**记录中。
    *   **最终产物**: 重构后的代码（需包含中文注释）、重构过程的决策记录（文件内容应为中文），建议保存为 `exercise_2_8_refactored_code.[py|java|...]` 和 `exercise_2_8_ai_assisted_refactoring_log.md`。

### Ex2_9_StructuredDevelopment : 结构化开发流程实践 (需求 -> TODO -> 测试 -> 编码)

*   **目标**: 完整实践从需求到编码的结构化流程，强调在 AI 辅助下进行任务分解、测试优先和迭代编码，**刻意避免直接让 AI 大段生成代码 (Vibe Coding)**，训练更有条理和工程化的开发思维。
*   **核心理念**: 让 AI 参与到软件开发的多个环节，人类负责高层设计、分解、定义标准和最终决策，AI 作为助手加速各个环节的执行。
*   **输入**: 
    *   所有相关的设定文件 (竞争、行业、技术) (`./setting/*`).
    *   `./module02/feature_spec_structured_dev.md` (一个相对完整的模块或功能需求文档)
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范)
    *   项目代码结构和相关接口定义。
*   **AI 助手 (Cursor) 的角色**:
    *   **需求理解与任务分解**: **阅读需求文档，协助将其分解为更小的、可管理的开发任务或 TODO 列表**，并与用户确认。
    *   **测试用例设计 (针对任务)**: **针对分解后的某个任务，协助设计或生成其单元测试用例的框架或关键断言**。
    *   **编码实现 (基于测试和任务)**: **根据明确的任务描述和对应的测试用例，生成实现代码**。
    *   **迭代与反馈**: **根据测试结果或用户的进一步指令，对生成的代码进行迭代修改或重构**。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_9_StructuredDevelopment/`
    *   **主要输出**: 练习中的需求理解、任务分解、测试用例设计、编码实现、迭代修改过程主要体现在**交互对话**记录中。
    *   **最终产物**: 任务分解列表（文件内容应为中文）、对应的测试用例、最终实现的代码（代码需包含中文注释）、开发流程日志（文件内容应为中文），建议保存为 `exercise_2_9_task_list.md`, `exercise_2_9_feature_impl_tests.[py|java|...]`, `exercise_2_9_feature_impl.[py|java|...]` 和 `exercise_2_9_structured_dev_flow_log.md`。

### Ex2_10_SpecDrivenDevelopment : 基于规约的代码生成 (Specification-Driven Development)

*   **目标**: 实践**基于精确规约 (Specification) 生成代码**。例如，给定一个 OpenAPI (Swagger) 规约文件，让 AI 生成符合该规约的 API 服务端骨架代码（路由、请求/响应模型、基础验证），体验规约驱动开发的高效性。
*   **核心理念**: 将人的工作重点放在**精确定义"做什么" (规约)** 上，由 AI 负责生成符合规约的"怎么做" (代码骨架)，人类再填充核心业务逻辑。这是将 AI 用于标准化代码生成的有效方式。
*   **输入**: 
    *   `./setting/setting_technology_trends.md` (了解 API 实现技术)。
    *   `./module02/api_specification_example.yaml` (示例 OpenAPI 文件)。
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (项目技术栈信息和代码风格规范)
*   **AI 助手 (Cursor) 的角色**:
    *   **解析规约**: 理解 OpenAPI 文件中的路径、操作、参数、模式 (Schema)。
    *   **生成骨架代码**: **根据规约生成对应的路由处理函数框架、数据模型类 (DTOs/POJOs) 以及基础的请求验证逻辑**，需遵循指定的代码风格。
    *   **确保一致性**: 保证生成的代码与规约严格匹配。
    *   **引导业务逻辑填充**: 在生成的骨架代码中，**明确标记出需要用户填充具体业务实现的 TODO 位置**。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_10_SpecDrivenDevelopment/`
    *   **主要输出**: 练习中规约解析、骨架代码生成过程主要体现在**交互对话**记录中。
    *   **最终产物**: 符合 OpenAPI 规约的 API 骨架代码（代码需包含中文注释或 TODO 说明）、生成过程日志（文件内容应为中文），建议保存为 `exercise_2_10_api_impl_skeleton.[py|java|...]` 和 `exercise_2_10_spec_driven_api_gen_log.md`。

### Ex2_11_ArchitectureAware : 架构模式遵从性代码生成 (Architecture-Aware Generation)

*   **目标**: 在添加新功能模块时，练习**指导 AI 生成严格遵守项目中既定架构模式** (例如，六边形架构、分层架构、事件驱动模式等) 的代码，确保代码风格和结构的一致性。
*   **核心理念**: 人类负责定义和维护项目的整体架构，并**教会/引导 AI 在特定架构约束下生成代码**，利用 AI 的模式学习能力来维护架构一致性，避免 AI 生成的代码破坏既定规范。
*   **输入**: 
    *   `./module02/existing_module_example/` (现有代码库中体现架构模式的示例代码)
    *   `./module02/architecture_overview.md` (架构说明文档或图表)
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范)。
    *   新功能需求描述。
*   **AI 助手 (Cursor) 的角色**:
    *   **分析现有架构**: **学习现有代码示例，理解分层、依赖关系、命名约定和接口定义方式**。
    *   **按模式生成**: 根据用户指令 ("请为新功能 X 创建一个符合我们六边形架构的服务类") 和学习到的模式，**在新模块中生成符合指定架构模式的类、接口和函数框架**。 **(若提供了开发规范) 确保生成的代码符合规范**。
    *   **接口定义提示**: 在需要定义新的接口或 DTO 时，**基于现有模式向用户发出建议或提示**。
    *   **依赖检查**: (可选) **检查生成的代码是否引入了不符合架构约定的依赖** (例如，Domain 层依赖了 Infrastructure 层)。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_11_ArchitectureAware/`
    *   **主要输出**: 练习中架构分析、按模式生成代码的过程主要体现在**交互对话**记录中。
    *   **最终产物**: 遵守项目架构模式的新模块代码框架（代码需包含中文注释或 TODO 说明）、生成过程日志（文件内容应为中文），建议保存为 `exercise_2_11_new_feature_module/` 目录下的文件和 `exercise_2_11_architecture_aware_gen_log.md`。

### Ex2_12_ComplexLogic : AI 辅助复杂逻辑实现与优化

*   **目标**: 针对一个具有一定复杂度的算法或业务逻辑（例如，多模态数据融合的核心逻辑、复杂的定价规则计算），练习**利用 AI 辅助实现、解释和优化**，体验 AI 作为解决复杂问题的"结对编程"伙伴。
*   **核心理念**: 将 AI 作为**解决复杂问题的伙伴**，人类负责清晰地定义问题、输入输出、约束条件和评估标准，AI 提供实现思路、代码草稿、解释、性能分析和优化建议，人类进行评估和决策。
*   **输入**: 
    *   `./setting/setting_technology_trends.md` (参考相关算法或优化技术)。
    *   `./setting/setting_industry_adoption.md` (特定行业的性能或精度要求)。
    *   `./module02/complex_logic_description.md` (复杂逻辑的文字描述或伪代码)
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范，可能影响实现方式或命名)。
    *   性能要求或优化目标 (例如，时间复杂度、内存限制、特定场景的响应时间)。
    *   相关的输入/输出数据结构定义。
*   **AI 助手 (Cursor) 的角色**:
    *   **理解与澄清逻辑**: **阅读并解释复杂逻辑描述**，通过提问与用户确认理解是否准确、完整。
    *   **生成初步实现**: **根据描述生成算法或逻辑的初步代码实现**，可能提供多种思路。 **(若提供了开发规范) 确保实现符合规范**。
    *   **解释代码与权衡**: **清晰地解释生成的代码是如何工作的，以及不同实现思路之间的权衡** (trade-offs)。
    *   **性能分析与优化建议**: **根据用户提供的性能要求或自动分析，识别潜在瓶颈，并提出具体的优化建议或替代实现方案** (例如，算法改进、数据结构优化、利用特定库等)。
    *   **应用优化**: 根据用户的选择应用优化方案，并解释优化后的效果。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_12_ComplexLogic/`
    *   **主要输出**: 练习中逻辑理解、代码生成、解释、性能分析、优化建议和应用过程主要体现在**交互对话**记录中。
    *   **最终产物**: 复杂逻辑的实现代码 (可能包含优化后的版本，代码需包含中文注释)、详细的分析优化日志（文件内容应为中文），建议保存为 `exercise_2_12_complex_logic.[py|java|...]` 和 `exercise_2_12_complex_logic_impl_log.md`。

### Ex2_13_SolutionExploration : AI 驱动的解决方案探索 (Heuristic Programming / AI-Led Exploration)

*   **目标**: 实践一种探索性的 AI 协作模式，针对一个开放式设计问题或优化目标，**启发 AI 生成多种解决方案或设计思路**，人类扮演引导者和评估者的角色，进行启发式提问和决策。
*   **核心理念**: 利用 AI 的生成和联想能力进行发散性思考和方案探索，人类负责设定高层目标、评估权衡并引导探索方向，而非提供精确指令。
*   **输入**: 
    *   `./setting/setting_technology_trends.md`
    *   `./setting/setting_competitive_landscape.md` (可能影响方案选择)
    *   `./setting/setting_industry_adoption.md` (可能影响方案选择)
    *   `./module02/open_ended_problem_description.md` (一个开放式设计问题或优化目标 - 如"为 NovaBrain 设计灵活的插件机制"或"探索多种优化模型冷启动时间的方法")
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范，可能约束方案)
    *   相关的背景信息（技术栈、现有架构、业务约束等）。
*   **AI 助手 (Cursor) 的角色**:
    *   **问题理解与目标澄清**: **阅读开放式问题描述，与用户讨论以确保理解目标和关键约束**。
    *   **多方案生成与解释**: **主动提出多种不同的解决方案、架构选项或实现思路**，并清晰地解释每种方案的**工作原理、优缺点和潜在权衡 (trade-offs)**。
    *   **启发式对话与深入探索**: **根据用户的反馈和追问 (例如"这种方案在并发场景下表现如何？""对比方案 A 和 B，哪个更易于扩展？")，对特定方案进行更深入的分析或细化**。
    *   **概念验证代码 (可选)**: (可选) 为选定的方案生成简单的概念验证代码片段。 **(若提供了开发规范) PoC 代码需尽量符合规范**。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_13_SolutionExploration/`
    *   **主要输出**: 练习中 AI 提出的多种解决方案、对方案的解释与权衡、与用户的启发式讨论过程主要体现在**交互对话**记录中。
    *   **最终产物**: 探索过程的总结（文件内容应为中文）、各种方案的对比分析（文件内容应为中文）、(可选的) 概念验证代码（需包含中文注释），建议保存为 `exercise_2_13_solution_exploration_log.md` 和 (可选) `exercise_2_13_poc_snippets/`。

### Ex2_14_ComplexDebugging : AI 辅助调试复杂场景

*   **目标**: 模拟一个复杂的 Bug 场景（例如，涉及多模块交互、并发问题或难以复现的错误），练习利用 AI 分析日志、堆栈跟踪、甚至相关代码片段，**协助诊断问题的根本原因**，体验 AI 作为高级调试伙伴的能力。
*   **核心理念**: 将 AI 作为**高级调试伙伴**。人类提供尽可能多的上下文信息（日志、错误信息、相关代码、架构图），引导 AI 进行关联分析、提出假设、甚至建议下一步的调试步骤或需要添加的诊断代码，加速复杂问题的定位过程。
*   **输入**: 
    *   `./setting/setting_technology_trends.md` (了解调试工具和技术)。
    *   `./module02/bug_scenario_logs.txt` (模拟的错误日志)
    *   `./module02/stack_trace_example.txt` (相关的堆栈跟踪信息)
    *   `./module02/architecture_overview.md` (系统架构图或模块交互说明)
    *   涉及问题的代码片段或模块。
    *   问题描述和复现步骤（可能不完全清晰）。
*   **AI 助手 (Cursor) 的角色**:
    *   **信息整合与关联**: **阅读并整合来自日志、堆栈跟踪和代码的信息**，尝试建立它们之间的联系。
    *   **模式识别与假设提出**: **尝试识别错误模式 (如特定异常频繁出现、时间关联性等)，并提出关于 Bug 可能根源的假设** (例如，"日志中的超时错误和这段代码的锁使用可能有关联" 或 "根据堆栈信息，空指针可能发生在 X 对象的 Y 方法调用中")。
    *   **代码分析 (针对性)**: **根据假设，对特定的代码段进行更深入的分析**，查找潜在逻辑错误、资源竞争或不当的 API 使用。
    *   **调试建议**: **建议添加哪些具体的日志语句、设置哪些断点，或者执行哪些特定的测试来验证提出的假设**。
    *   **解释复杂错误**: (可选) 解释某些底层库、框架或系统层面的错误信息。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_14_ComplexDebugging/`
    *   **主要输出**: 练习中的信息整合分析、AI 提出的假设、调试建议、根本原因推断过程主要体现在**交互对话**记录中。
    *   **最终产物**: 调试过程的分析记录和最终定位的（模拟）根本原因（文件内容应为中文），建议保存为 `exercise_2_14_complex_debugging_log.md`。

### Ex2_15_CrossFileRefactoring : 跨文件/模块的自动化重构与一致性维护

*   **目标**: 练习**指导 AI 执行涉及多个文件或模块的、更大型的重构任务**，例如更改一个核心接口后，自动更新所有调用点的代码；或者在整个代码库中统一应用某种命名约定或代码模式，确保代码库的一致性。
*   **核心理念**: 利用 AI **理解代码库结构和跨文件依赖关系**的能力，执行简单的查找替换无法完成的、需要理解代码语义的全局性变更。人类负责定义变更目标和范围，并仔细审查 AI 的执行结果。
*   **输入**: 
    *   代码库的相关部分 (至少包含需要修改的多个文件/模块)。
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范)
    *   需要进行全局变更的任务描述 (例如，"将旧的 `LoggerFacade` 替换为新的 `LoggerInterface`，并更新所有实现和调用点" 或 "统一所有 Service 类的 `handleRequest` 方法签名使其接受 `Context` 对象")。
*   **AI 助手 (Cursor) 的角色**:
    *   **影响分析**: **根据变更描述，分析并列出可能受影响的文件和具体的代码位置**。
    *   **批量代码修改**: **根据用户确认的范围和具体修改逻辑 (例如，接口方法签名变更、类名替换等)，自动对多个文件执行代码修改**。
    *   **一致性检查**: (可选) **检查修改后的代码是否在语法、类型或接口签名上保持了一致性**，是否存在编译错误。
    *   **报告变更集**: **清晰地报告所有被修改的文件和具体的变更内容 (例如生成 diff 或总结列表)**，供用户审查。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_15_CrossFileRefactoring/`
    *   **主要输出**: 练习中的影响分析、批量修改的指令和结果、变更报告主要体现在**交互对话**记录中。
    *   **最终产物**: 经过批量修改的代码文件（代码需包含中文注释）、变更总结报告（文件内容应为中文），建议保存为 `exercise_2_15_updated_codebase_part/` 目录下的文件或 `exercise_2_15_cross_file_refactoring_summary.md`。

### Ex2_16_CodeReview_LogicRisk : AI 辅助进行代码评审 (逻辑与风险导向)

*   **目标**: 模拟代码评审 (Code Review) 过程，**重点利用 AI 识别超越简单风格问题的潜在逻辑错误、性能陷阱、安全漏洞或未处理的边界情况**，提升代码评审的深度和效率。
*   **核心理念**: 将 AI 作为**智能代码评审员**。人类提供需要评审的代码（例如一个 Pull Request 的 diff 或特定文件），并可以提出关注点（"请检查这里的并发安全性"或"评估这个算法的效率"），AI 基于其知识库、代码分析能力和对上下文的理解，提供深入的、超越 Linter 的反馈。
*   **输入**: 
    *   `./setting/setting_technology_trends.md` (了解常见的性能/安全模式)。
    *   `./setting/setting_industry_adoption.md` (行业相关的风险点，如医疗数据处理合规)。
    *   `./module02/code_review_diff_example.patch` (一段需要评审的代码变更 或指定文件/函数)
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (开发规范)
    *   相关的上下文代码或需求说明。
    *   (可选) 用户明确提出的评审关注点。
*   **AI 助手 (Cursor) 的角色**:
    *   **理解变更意图与上下文**: **尝试理解代码变更的目的和其在整个系统中的作用**。
    *   **潜在问题识别 (深度)**: **主动识别代码中可能存在的逻辑缺陷、未处理的异常或边缘情况、潜在的性能瓶颈 (如循环内数据库查询)、常见的安全漏洞模式 (如 SQL 注入风险点、不安全的输入处理、权限校验缺失等)、并发问题（如竞态条件风险）或不符合最佳实践的设计**。
    *   **提出具体建议与解释**: **针对识别出的问题，提出具体的修改建议、替代方案或需要进一步讨论的问题，并解释为什么这是一个问题以及可能的风险**。
    *   **规范符合性检查**: (若提供了规范) **检查代码是否符合团队的开发规范 (超越简单的格式问题)**。
    *   **提问引导**: (可选) 提出引导性问题，促使开发者思考更深层次的设计或影响 ("这个改动对下游依赖有什么影响吗？" "大数据量情况下这里性能如何？")。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_16_CodeReview_LogicRisk/`
    *   **主要输出**: 练习中 AI 生成的代码评审意见、识别出的潜在问题列表、修改建议、解释和引导性问题主要体现在**交互对话**记录中。
    *   **最终产物**: AI 生成的代码评审反馈报告（文件内容应为中文），建议保存为 `exercise_2_16_ai_code_review_feedback.md`。

### Ex2_17_DocAndSwaggerGeneration : AI 辅助文档和 API 规范生成

*   **目标**: 探索 AI 在自动生成技术文档和 API 规范 (如 Swagger/OpenAPI) 方面的能力，提高文档的质量和一致性，降低文档维护成本。
*   **核心理念**: 将文档和接口规范视为代码的一等公民，利用 AI 协助开发者生成高质量的文档和 API 规范，确保文档与代码保持同步，并满足医疗等行业对文档完整性和准确性的严格要求。
*   **输入**: 
    *   `./setting/case_study_NovaBrain.md` (了解医疗场景需求)
    *   `./setting/setting_industry_adoption.md` (行业文档标准要求)
    *   `./module02/api_implementation_example.[py|java|...]` (已实现的 API 代码)
    *   `./module02/code_structure_backend_services.md` (代码结构说明)
    *   `./module02/dev_standards_documentation_strategy_v0.9.md` (文档化策略)
*   **AI 助手 (Cursor) 的角色**:
    *   **代码分析与理解**: **分析现有 API 代码，理解其路由结构、参数定义、响应模式和业务逻辑**。
    *   **Swagger/OpenAPI 规范生成**: **根据代码分析结果，生成符合 OpenAPI 3.0 规范的 API 文档，包括路径、操作、参数描述、请求/响应模式、示例值和状态码**。
    *   **代码注释优化**: **提出改进现有代码注释的建议，确保注释质量和覆盖率**，特别关注医疗等行业对文档完整性的要求。
    *   **技术文档生成**: **生成其他形式的技术文档，如 API 使用指南、集成文档或模块说明**。
    *   **文档一致性检查**: **检查生成的文档与代码实际行为是否一致**，识别潜在的不一致点，并提出修复建议。
*   **输出位置与方式**:
    *   **输出目录**: `./output_module02/Ex2_17_DocAndSwaggerGeneration/`
    *   **主要输出**: 练习中 AI 对代码的分析、Swagger 规范的生成过程、注释优化建议和技术文档生成主要体现在**交互对话**记录中。
    *   **最终产物**: 生成的 OpenAPI 规范 (`.yaml` 或 `.json` 文件)、改进后的 API 代码 (包含优化的注释)、其他技术文档 (如 API 使用指南，文件内容应为中文)，建议保存为 `exercise_2_17_api_openapi_spec.[yaml|json]`、`exercise_2_17_api_code_with_improved_docs.[py|java|...]` 和 `exercise_2_17_api_integration_guide.md`。

--- 