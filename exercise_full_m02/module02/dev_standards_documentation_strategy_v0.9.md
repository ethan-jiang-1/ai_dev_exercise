# NovaBrain 3.0 开发规范与文档化策略 (草案 v0.9)

**文档版本**: 0.9
**状态**: 草案
**制定日期**: 2023-11-10
**负责人**: 王强 (工程负责人)

## 1. 引言

### 1.1 目的
本文档旨在为 NovaBrain 3.0 项目团队提供一套统一的开发规范和文档化策略，以提高代码质量、增强可维护性、促进团队协作效率，并确保产品满足相关行业的合规要求（特别是医疗领域）。

### 1.2 范围
本规范适用于 NovaBrain 3.0 平台所有后端服务、前端应用、AI/ML 模型代码、基础设施代码以及相关技术文档的开发和维护过程。

### 1.3 AI 可读性原则
本文档在编写时，力求结构清晰、语言明确，以便 AI 助手（如 Cursor）能够理解和应用其中的规则，辅助开发人员进行代码生成、重构、评审和文档编写。关键约定使用 Markdown 标题、列表、代码块等格式清晰标示。

## 2. 编码规范

### 2.1 语言与风格

*   **后端主要语言**: Python (>= 3.9), Java (>= 17)
*   **前端主要框架**: React (TypeScript)
*   **代码风格**:
    *   **Python**: 强制遵循 [PEP 8](https://www.python.org/dev/peps/pep-0008/) 规范。推荐使用 `Black` 进行自动格式化，`Flake8` 和 `MyPy`进行静态检查。
    *   **Java**: 遵循 [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)。推荐使用 IDE (如 IntelliJ IDEA) 的格式化工具统一风格。
    *   **TypeScript/React**: 遵循 [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) 及相关的 React/JSX 规范。推荐使用 `Prettier` 和 `ESLint` (配置相应的插件) 进行格式化和风格检查。
*   **命名约定**:
    *   变量、函数、方法名使用小写蛇形命名法 (`snake_case`) (Python) 或小驼峰命名法 (`lowerCamelCase`) (Java/TypeScript)。
    *   类名使用大驼峰命名法 (`UpperCamelCase`)。
    *   常量使用全大写蛇形命名法 (`ALL_CAPS_SNAKE_CASE`)。
    *   命名应清晰、表意明确，避免使用无意义或过于简写的名称。

### 2.2 代码注释

*   **必要性**: 对复杂的逻辑、算法、重要的业务规则、接口定义（特别是公共 API）以及需要特殊处理的代码段必须添加注释。
*   **风格**:
    *   Python: 使用 Docstrings (遵循 [PEP 257](https://www.python.org/dev/peps/pep-0257/)) 解释模块、类、函数/方法的用途、参数、返回值和可能抛出的异常。行内注释使用 `#`。
    *   Java: 使用 Javadoc 解释类、接口、方法、字段。行内注释使用 `//`。
    *   TypeScript/React: 使用 TSDoc 或 JSDoc 风格注释。行内注释使用 `//`。
*   **质量**: 注释应简洁明了，解释 *为什么* 这么做，而不是 *怎么* 做的（代码本身应清晰可读）。避免无用、过时或误导性的注释。

### 2.3 错误处理

*   **异常使用**: 合理使用异常来处理错误情况，避免使用错误码或返回 `null` (除非明确约定)。
*   **异常捕获**: 精确捕获预期可能发生的特定异常，避免捕获宽泛的 `Exception` 或 `Throwable` (除非有充分理由并进行日志记录)。
*   **日志记录**: 在关键的错误处理点记录详细的日志信息，包括错误类型、上下文信息和堆栈跟踪。

### 2.4 依赖管理

*   **Python**: 使用 `pip` 和 `requirements.txt` (或 `pyproject.toml` 与 Poetry/PDM) 管理依赖，明确锁定版本号。
*   **Java**: 使用 Maven (`pom.xml`) 或 Gradle (`build.gradle`) 管理依赖，明确依赖版本。
*   **Node.js/Frontend**: 使用 `npm` 或 `yarn` 管理依赖 (`package.json`, `package-lock.json`/`yarn.lock`)，锁定版本。
*   **原则**: 最小化依赖项，定期审查和更新依赖版本，注意许可证合规性。

## 3. 测试规范

### 3.1 测试类型与要求

*   **单元测试 (Unit Tests)**:
    *   **强制要求**: 所有核心业务逻辑、工具类、复杂算法必须有单元测试覆盖。
    *   **目标覆盖率**: 核心模块 strive for 80% 行覆盖率。
    *   **框架**: Python (`pytest`), Java (`JUnit 5`, `Mockito`), TypeScript (`Jest`, `React Testing Library`)。
    *   **原则**: 测试应快速、独立、可重复、自验证 (FIRST 原则)。
*   **集成测试 (Integration Tests)**:
    *   **要求**: 测试模块之间、服务与数据库/消息队列/外部 API 等关键集成点。
    *   **框架**: 可利用单元测试框架，结合 Mocking 或真实的依赖服务 (如使用 Testcontainers)。
*   **端到端测试 (End-to-End Tests)**:
    *   **要求**: 覆盖关键的用户场景和业务流程。
    *   **框架**: `Cypress`, `Playwright`, `Selenium`。
    *   **重点**: 关注核心路径的正确性，不必追求全面覆盖。
*   **性能测试**: 针对关键 API 和核心处理流程制定性能测试计划（参考 Module 03）。
*   **安全测试**: 定期进行安全扫描和渗透测试（参考 Module 03）。

### 3.2 测试驱动开发 (TDD)
*   **推荐实践**: 鼓励在开发新功能或修复 Bug 时采用 TDD 流程（红-绿-重构）。
*   **AI 协同**: 可利用 AI 助手根据需求或测试意图生成测试用例框架，或基于测试生成初步实现代码（参见 Ex2_7）。

### 3.3 测试数据管理
*   测试数据应与生产数据隔离。
*   对于涉及敏感信息的测试（特别是医疗数据），必须使用脱敏或完全合成的数据。
*   测试数据应易于生成、维护和清理。

## 4. 文档化策略

### 4.1 文档类型与要求

*   **代码级文档**: 通过规范的注释 (Docstrings, Javadoc, TSDoc) 实现。
*   **API 文档**:
    *   **强制要求**: 所有对外暴露的 RESTful API 必须提供 OpenAPI (Swagger) 规范。
    *   **工具**: 可利用代码注解自动生成 (如 `springdoc-openapi` for Java Spring, `FastAPI` built-in support for Python) 或手动编写/维护。鼓励 AI 辅助生成（参见 Ex2_17）。
    *   **内容**: 清晰描述端点、参数、请求/响应体、认证方式、状态码和示例。
*   **架构文档**:
    *   包含高层架构图、关键组件说明、技术选型决策 (如 ADRs - Architecture Decision Records)。
    *   使用 Markdown 格式，图表可嵌入或链接。
*   **设计文档**: 针对重要模块或复杂功能的技术设计文档。
*   **用户/集成文档**: 面向最终用户或第三方集成者的使用指南、配置手册等。
*   **运维文档**: 部署说明、监控配置、应急预案等。

### 4.2 文档维护

*   **原则**: 文档应与代码保持同步。代码变更时，相关文档（特别是 API 文档和设计文档）必须同步更新。
*   **责任**: 功能开发者负责更新相关的代码级文档、API 文档和设计文档。架构师/Tech Lead 负责维护架构文档。
*   **评审**: 文档（特别是 API 和架构文档）应纳入代码评审流程。

### 4.3 文档存储与访问
*   所有技术文档应存储在版本控制系统 (如 Git) 的 `docs/` 目录下或专门的文档库中。
*   提供统一的内部文档门户或 Wiki (如 Confluence) 便于团队查阅。

## 5. 版本控制与代码提交

### 5.1 版本控制系统
*   **系统**: Git
*   **平台**: GitHub / GitLab / Bitbucket (根据公司实际情况)

### 5.2 分支策略
*   **推荐模型**: Gitflow 或 GitHub Flow (根据团队规模和发布节奏选择)。
    *   `main`/`master`: 稳定的生产代码。
    *   `develop`: 集成开发分支。
    *   `feature/xxx`: 功能开发分支。
    *   `release/vx.y.z`: 发布准备分支。
    *   `hotfix/xxx`: 生产 Bug 修复分支。
*   **原则**: 禁止直接向 `main`/`master` 或 `develop` 分支提交代码。所有开发活动在 `feature` 分支进行。

### 5.3 提交规范 (Commit Message)
*   **强制要求**: 遵循 [Conventional Commits](https://www.conventionalcommits.org/) 规范。
*   **格式**: `<type>[optional scope]: <description>`
    *   **Types**: `feat`, `fix`, `build`, `chore`, `ci`, `docs`, `style`, `refactor`, `perf`, `test`, etc.
*   **目的**: 方便生成 Changelog，利于代码历史追溯和自动化处理。

### 5.4 代码评审 (Code Review)
*   **强制要求**: 所有合并到 `develop` 或 `main`/`master` 的代码必须经过至少一位其他团队成员的评审 (Review)。
*   **流程**: 通过 Pull Request (PR) / Merge Request (MR) 进行。
*   **关注点**:
    *   功能正确性、完整性。
    *   是否符合设计要求和开发规范。
    *   代码可读性、可维护性。
    *   测试覆盖率和测试质量。
    *   潜在的逻辑错误、性能问题、安全风险 (可利用 AI 辅助，参见 Ex2_16)。
    *   文档是否同步更新。
*   **评审人责任**: 及时响应评审请求，提出建设性意见。
*   **提交者责任**: 对评审意见进行回应和修改，确保代码质量。

## 6. 特殊注意事项 (AI/ML & 医疗合规)

### 6.1 AI/ML 模型开发
*   **模型版本控制**: 使用 DVC 或类似工具管理模型文件和大型数据集。
*   **实验跟踪**: 使用 MLflow, Weights & Biases 等工具记录实验参数、指标和结果。
*   **模型可解释性 (XAI)**: 对于关键决策模型（特别是医疗相关），需考虑并记录采用的可解释性方法和结果。
*   **模型监控**: 建立模型性能监控机制，关注概念漂移和性能衰减。

### 6.2 医疗行业合规 (示例)
*   **数据隐私**: 严格遵守 HIPAA (如适用) 或相应地区的医疗数据隐私法规，处理个人身份信息 (PII) 和受保护健康信息 (PHI) 时必须进行脱敏或匿名化处理。
*   **数据安全**: 加强数据传输和存储的加密，实施严格的访问控制。
*   **可追溯性**: 确保开发过程、测试结果、模型训练过程的可追溯性，满足审计要求。代码提交记录、测试报告、实验记录等需妥善保存。
*   **风险管理**: 针对 AI/ML 在医疗场景应用的特定风险（如误诊、偏见）进行评估和管理。

## 7. 规范的执行与改进

*   **工具自动化**: 尽可能利用 Linting、格式化、静态分析、CI/CD 流水线等工具强制执行部分规范。
*   **培训与宣导**: 定期组织团队学习和讨论开发规范。
*   **持续改进**: 本规范并非一成不变，团队应定期回顾其有效性，并根据项目进展和技术发展进行修订。欢迎团队成员提出改进建议。

--- 